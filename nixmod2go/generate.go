package nixmod2go

import (
	_ "embed"
	"fmt"
	"go/doc/comment"
	"log/slog"
	"maps"
	"slices"
	"strings"

	"github.com/diamondburned/gotk4/gir/girgen/cmt"
	"github.com/diamondburned/gotk4/gir/girgen/strcases"
	"libdb.so/nixmod2go/nixmodule"

	gen "github.com/moznion/gowrtr/generator"
)

// Generate generates Go struct definitions from Nix modules.
func Generate(packageName string, module nixmodule.Module) (string, error) {
	slog := slog.With("package", packageName)

	f := generatingFile{
		imports: make(map[string]struct{}),
		slog:    slog,
	}

	slog.Debug("generating Go struct definitions from Nix modules")
	f.generate(sortModule(module))

	return gen.NewRoot().
		AddStatements(
			gen.NewComment(" Code generated by nixmod2go. DO NOT EDIT."),
			gen.NewPackage(packageName),
			gen.NewNewline(),
		).
		AddStatements(
			f.importStatement(),
			gen.NewNewline(),
		).
		AddStatements(f.statements...).
		Gofmt("-s").
		Generate(0)
}

type generatingFile struct {
	statements []gen.Statement
	imports    map[string]struct{}
	slog       *slog.Logger
}

func (g *generatingFile) generate(root sortedModule) {
	for _, item := range root {
		name := parseName(item.Name)
		path := modulePath{name}
		g.generateItemType(path, item)
	}
}

func (g *generatingFile) generateItemType(path modulePath, item optionItem) string {
	g.slog.Debug(
		"generating item type",
		"path", path,
		"name", item.Name,
		"item.Module", item.Module != nil,
		"item.Option", item.Option != nil)

	name := parseName(item.Name)
	switch {
	case item.Module != nil:
		return g.generateModuleType(name, path, *item.Module)
	case item.Option != nil:
		return g.generateOptionType(name, path, *item.Option)
	default:
		panic("unreachable")
	}
}

func (g *generatingFile) generateModuleType(name optionName, path modulePath, module sortedModule) string {
	g.slog.Debug(
		"generating module type",
		"path", path,
		"name", name.Nix,
		"module", module.Keys())

	// Manually generate a struct here. `gen` doesn't support adding comments
	// before each struct field for some reason?
	var s strings.Builder

	fmt.Fprintf(&s, "type %s struct {\n", name.Go)
	for _, item := range module {
		valueName := parseName(item.Name)
		valueType := g.generateItemType(path.Add(valueName), item)

		if item.Option != nil && (*item.Option).Doc().Description != "" {
			if cmt := docComment((*item.Option).Doc(), valueName.Go, 1); cmt != "" {
				fmt.Fprint(&s, cmt)
			}
		}

		fmt.Fprintf(&s, "\t%s %s `json:%q`\n", valueName.Go, valueType, item.Name)
	}
	fmt.Fprintln(&s, "}")

	// Choose to prepend the struct. This is because [generateItemType] will
	// recursively generate its own type before we can append our struct in, so
	// it'll naturally appear at the end by the time we're here.
	g.prepend(
		gen.NewCommentf(" %s is the struct type for %s.", name.Go, path.GoDocForNixPath()),
		gen.NewRawStatement(s.String()),
	)

	return name.Go
}

func (g *generatingFile) generateOptionType(name optionName, path modulePath, option nixmodule.Option) string {
	g.slog.Debug(
		"generating option type",
		"path", path,
		"name", name.Nix,
		"option", option.Type())

	switch option := option.(type) {
	case nixmodule.StrOption:
		return "string"
	case nixmodule.IntOption:
		return "int"
	case nixmodule.IntBetweenOption:
		return "int"
	case nixmodule.PositiveIntOption:
		return "uint"
	case nixmodule.SignedInt8Option:
		return "int8"
	case nixmodule.SignedInt16Option:
		return "int16"
	case nixmodule.SignedInt32Option:
		return "int32"
	case nixmodule.UnsignedInt8Option:
		return "uint8"
	case nixmodule.UnsignedInt16Option:
		return "uint16"
	case nixmodule.UnsignedInt32Option:
		return "uint32"
	case nixmodule.UnsignedIntOption:
		return "uint"
	case nixmodule.PathOption:
		return "string"
	case nixmodule.BoolOption:
		return "bool"
	case nixmodule.FloatOption:
		return "float64"
	case nixmodule.AttrsOption:
		return "map[string]any"
	case nixmodule.AnythingOption:
		return "any"
	case nixmodule.UnspecifiedOption:
		g.addImport("encoding/json")
		return "json.RawMessage"
	case nixmodule.EnumOption:
		return g.generateEnumType(name, path, option)
	case nixmodule.SeparatedString:
		return "string" // TODO: generate type that has .Split()
	case nixmodule.UniqueOption:
		return g.generateOptionType(name, path, option.Unique)
	case nixmodule.EitherOption:
		if eitherIsNumber(option) {
			g.addImport("encoding/json")
			return "json.Number"
		}
		return g.generateEitherType(name, path, option)
	case nixmodule.NullOrOption:
		return "*" + g.generateOptionType(name, path, option.NullOr)
	case nixmodule.ListOfOption:
		return "[]" + g.generateOptionType(name, path, option.ListOf)
	case nixmodule.AttrsOfOption:
		return "map[string]" + g.generateOptionType(name, path, option.AtrrsOf)
	case nixmodule.SubmoduleOption:
		return g.generateModuleType(name, path, sortModule(option.Submodule))
	default:
		panic("unreachable")
	}
}

func (g *generatingFile) generateEnumType(name optionName, path modulePath, option nixmodule.EnumOption) string {
	// Manually construct this code since `gen` doesn't have either `type` or
	// `const` statements supported.
	var s strings.Builder

	fmt.Fprintf(&s, "type %s string\n", name.Go)
	fmt.Fprintln(&s)

	fmt.Fprintln(&s, "const (")
	for _, value := range option.Enum {
		valueName := parseName(value)
		fmt.Fprintf(&s, "%s %s = %q\n", name.Go+valueName.Go, name.Go, value)
	}
	fmt.Fprintln(&s, ")")

	g.append(
		gen.NewCommentf(" %s is the enum type for %s.", name.Go, path.GoDocForNixPath()),
		gen.NewRawStatement(s.String()),
	)

	return name.Go
}

func (g *generatingFile) generateEitherType(name optionName, path modulePath, option nixmodule.EitherOption) string {
	iface := []gen.Statement{
		gen.NewCommentf(" %s describes the `either` type for %s.", name.Go, path.GoDocForNixPath()),
		gen.NewInterface(name.Go, gen.NewFuncSignature("is"+name.Go)),
	}

	var types []gen.Statement
	var typeMethods []gen.Statement
	var typeFuncs []gen.Statement

	for _, option := range option.Either {
		optionName := parseName(option.Type())
		optionName.Go = name.Go + optionName.Go

		optionType := g.generateOptionType(optionName, path, option)

		types = append(types,
			gen.NewCommentf(" %s is one of the types that satisfy [%s].", optionName.Go, name.Go),
			gen.NewRawStatementf("type %s %s", optionName.Go, optionType))

		typeMethods = append(typeMethods, gen.NewFunc(
			gen.NewFuncReceiver(strcases.FirstLetter(optionName.Go), optionName.Go),
			gen.NewFuncSignature("is"+name.Go),
		))

		typeFuncs = append(typeFuncs,
			gen.NewCommentf(" New%s constructs a value of type `%s` that satisfies [%s].", optionName.Go, option.Type(), name.Go),
			gen.NewFunc(nil,
				gen.NewFuncSignature("New"+optionName.Go).
					AddParameters(gen.NewFuncParameter(strcases.FirstLetter(optionName.Go), optionType)).
					AddReturnTypes(name.Go),
				gen.NewReturnStatement(fmt.Sprintf("%s(%s)", optionName.Go, strcases.FirstLetter(optionName.Go))),
			))
	}

	g.append(iface...)
	g.append(types...)
	g.append(typeMethods...)
	g.append(typeFuncs...)

	return name.Go
}

func (g *generatingFile) append(stmts ...gen.Statement) {
	g.statements = append(g.statements, stmts...)
	g.statements = append(g.statements, gen.NewNewline())
}

func (g *generatingFile) prepend(stmts ...gen.Statement) {
	g.statements = slices.Concat(stmts, []gen.Statement{gen.NewNewline()}, g.statements)
}

func (g *generatingFile) addImport(url string) {
	g.imports[url] = struct{}{}
}

func (g *generatingFile) importStatement() gen.Statement {
	return gen.NewImport(slices.Collect(maps.Keys(g.imports))...)
}

func docComment(doc nixmodule.OptionDoc, what string, indentLvl int) string {
	if doc.Description == "" {
		return ""
	}
	s := cmt.FixGrammar(what, doc.Description)
	return fmtComment(s, indentLvl)
}

func fmtComment(s string, indentLvl int) string {
	printer := &comment.Printer{
		TextPrefix:     strings.Repeat(" ", cmt.CommentsTabWidth*indentLvl) + "// ",
		TextCodePrefix: strings.Repeat(" ", cmt.CommentsTabWidth*indentLvl) + "//\t",
	}
	s = string(printer.Text(new(comment.Parser).Parse(s)))
	return s
}
