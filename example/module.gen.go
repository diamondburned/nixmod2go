// Code generated by nixmod2go. DO NOT EDIT.
package example

import (
	"encoding/json"
	"errors"
)

// Config is the struct type for `config`.
type Config struct {
	Examples Examples `json:"examples"`
}

// Examples is the struct type for `config.examples`.
type Examples struct {
	Modules Modules `json:"modules"`
}

// Modules is the struct type for `config.examples.modules`.
type Modules struct {
	ComplexModule ComplexModule `json:"complexModule"`
}

// ComplexModule is the struct type for `config.examples.modules.complexModule`.
type ComplexModule struct {
	// Enable: whether to enable example-module.
	Enable bool `json:"enable"`
	// Package: example package option.
	Package string `json:"package"`
	// Anything: example anything option.
	Anything any `json:"anything"`
	// Attrs: example attrs option (treated as map[string]any).
	Attrs map[string]any `json:"attrs"`
	// Bool: example boolean option.
	Bool bool `json:"bool"`
	// Either: example either option (int or string).
	Either EitherJSON `json:"either"`
	// EitherSubmodule: submodule or path to the submodule.
	EitherSubmodule EitherSubmoduleJSON `json:"eitherSubmodule"`
	// Enum: example enum option.
	Enum Enum `json:"enum"`
	// Internal: example internal option.
	Internal bool `json:"internal"`
	// Lines: example lines option (treated as string).
	Lines string `json:"lines"`
	// Nullable: example nullable string option.
	Nullable *string `json:"nullable"`
	// NullableSubmodule: example nullable submodule option.
	NullableSubmodule *NullableSubmodule `json:"nullableSubmodule"`
	// Number: example number option.
	Number int `json:"number"`
	// Numbers: example for various ints.* options.
	Numbers Numbers `json:"numbers"`
	// OneOf: example oneOf option (int or string or bool).
	OneOf OneOfJSON `json:"oneOf"`
	// Path: example path option (treated as string).
	Path string `json:"path"`
	// Port: example port number option.
	Port uint16 `json:"port"`
	// String: example string option.
	String string `json:"string"`
	// StringAttrs: map[string]string option.
	StringAttrs map[string]string `json:"stringAttrs"`
	// StringList: list of strings.
	StringList []string `json:"stringList"`
	// Submodule: example submodule option.
	Submodule Submodule `json:"submodule"`
	// SubmoduleList: example list of submodules.
	SubmoduleList []SubmoduleList `json:"submoduleList"`
	// SubmoduleSelfRef: example submodule option that references its own name.
	SubmoduleSelfRef SubmoduleSelfRef `json:"submoduleSelfRef"`
	// Uniq: example unique string option.
	Uniq string `json:"uniq"`
}

// SubmoduleSelfRef is the struct type for `config.examples.modules.complexModule.submoduleSelfRef`.
type SubmoduleSelfRef struct {
	// CurrentName: name of the submodule.
	CurrentName string `json:"currentName"`
}

// SubmoduleList is the struct type for `config.examples.modules.complexModule.submoduleList`.
type SubmoduleList struct {
	// Enable: whether to enable submodule-list.
	Enable bool `json:"enable"`
}

// Submodule is the struct type for `config.examples.modules.complexModule.submodule`.
type Submodule struct {
	// InnerNullable: example nullable string option.
	InnerNullable *string `json:"innerNullable"`
	// InnerString: example string option.
	InnerString string `json:"innerString"`
}

// Numbers is the struct type for `config.examples.modules.complexModule.numbers`.
type Numbers struct {
	Between  int         `json:"between"`
	Float    float64     `json:"float"`
	Int      int         `json:"int"`
	Number   json.Number `json:"number"`
	Positive uint        `json:"positive"`
	S16      int16       `json:"s16"`
	S32      int32       `json:"s32"`
	S8       int8        `json:"s8"`
	U16      uint16      `json:"u16"`
	U32      uint32      `json:"u32"`
	U8       uint8       `json:"u8"`
	Unsigned uint        `json:"unsigned"`
}

// NullableSubmodule is the struct type for `config.examples.modules.complexModule.nullableSubmodule`.
type NullableSubmodule struct {
	// Enable: whether to enable nullable-submodule.
	Enable bool `json:"enable"`
}

// Either describes the `either` type for `config.examples.modules.complexModule.either`.
type Either interface {
	isEither()
}

// EitherInt is one of the types that satisfy [Either].
type EitherInt int

// EitherStr is one of the types that satisfy [Either].
type EitherStr string

func (e EitherInt) isEither() {
}
func (e EitherStr) isEither() {
}

// NewEitherInt constructs a value of type `int` that satisfies [Either].
func NewEitherInt(e int) Either {
	return EitherInt(e)
}

// NewEitherStr constructs a value of type `str` that satisfies [Either].
func NewEitherStr(e string) Either {
	return EitherStr(e)
}

// EitherJSON wraps [Either] and implements the json.Unmarshaler interface.
type EitherJSON struct{ Value Either }

// UnmarshalJSON implements the [json.Unmarshaler] interface for [Either].
func (e *EitherJSON) UnmarshalJSON(data []byte) error {
	v, err := unmarshalEither(data)
	if err != nil {
		return err
	}
	e.Value = v
	return nil
}

// MarshalJSON implements the [json.Marshaler] interface for [Either].
func (e EitherJSON) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.Value)
}

func unmarshalEither(data json.RawMessage) (Either, error) {

	var v0 int
	if err := json.Unmarshal(data, &v0); err == nil {
		return EitherInt(v0), nil
	}

	var v1 string
	if err := json.Unmarshal(data, &v1); err == nil {
		return EitherStr(v1), nil
	}

	return nil, errors.New("failed to unmarshal Either: unknown type received")
}

// EitherSubmodule describes the `either` type for `config.examples.modules.complexModule.eitherSubmodule`.
type EitherSubmodule interface {
	isEitherSubmodule()
}

// EitherSubmodulePath is one of the types that satisfy [EitherSubmodule].
type EitherSubmodulePath string

// EitherSubmoduleSubmodule is one of the types that satisfy [EitherSubmodule].
type EitherSubmoduleSubmodule struct {
	Hello string `json:"hello"`
}

func (e EitherSubmodulePath) isEitherSubmodule() {
}
func (e EitherSubmoduleSubmodule) isEitherSubmodule() {
}

// NewEitherSubmodulePath constructs a value of type `path` that satisfies [EitherSubmodule].
func NewEitherSubmodulePath(e string) EitherSubmodule {
	return EitherSubmodulePath(e)
}

// NewEitherSubmoduleSubmodule constructs a value of type `submodule` that satisfies [EitherSubmodule].
func NewEitherSubmoduleSubmodule(e struct {
	Hello string `json:"hello"`
}) EitherSubmodule {
	return EitherSubmoduleSubmodule(e)
}

// EitherSubmoduleJSON wraps [EitherSubmodule] and implements the json.Unmarshaler interface.
type EitherSubmoduleJSON struct{ Value EitherSubmodule }

// UnmarshalJSON implements the [json.Unmarshaler] interface for [EitherSubmodule].
func (e *EitherSubmoduleJSON) UnmarshalJSON(data []byte) error {
	v, err := unmarshalEitherSubmodule(data)
	if err != nil {
		return err
	}
	e.Value = v
	return nil
}

// MarshalJSON implements the [json.Marshaler] interface for [EitherSubmodule].
func (e EitherSubmoduleJSON) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.Value)
}

func unmarshalEitherSubmodule(data json.RawMessage) (EitherSubmodule, error) {

	var v0 string
	if err := json.Unmarshal(data, &v0); err == nil {
		return EitherSubmodulePath(v0), nil
	}

	var v1 struct {
		Hello string `json:"hello"`
	}
	if err := json.Unmarshal(data, &v1); err == nil {
		return EitherSubmoduleSubmodule(v1), nil
	}

	return nil, errors.New("failed to unmarshal EitherSubmodule: unknown type received")
}

// Enum is the enum type for `config.examples.modules.complexModule.enum`.
type Enum string

const (
	EnumA Enum = "a"
	EnumB Enum = "b"
	EnumC Enum = "c"
)

// OneOf describes the `either` type for `config.examples.modules.complexModule.oneOf`.
type OneOf interface {
	isOneOf()
}

// OneOfInt is one of the types that satisfy [OneOf].
type OneOfInt int

// OneOfStr is one of the types that satisfy [OneOf].
type OneOfStr string

// OneOfBool is one of the types that satisfy [OneOf].
type OneOfBool bool

// OneOfAttrs is one of the types that satisfy [OneOf].
type OneOfAttrs map[string]any

func (o OneOfInt) isOneOf() {
}
func (o OneOfStr) isOneOf() {
}
func (o OneOfBool) isOneOf() {
}
func (o OneOfAttrs) isOneOf() {
}

// NewOneOfInt constructs a value of type `int` that satisfies [OneOf].
func NewOneOfInt(o int) OneOf {
	return OneOfInt(o)
}

// NewOneOfStr constructs a value of type `str` that satisfies [OneOf].
func NewOneOfStr(o string) OneOf {
	return OneOfStr(o)
}

// NewOneOfBool constructs a value of type `bool` that satisfies [OneOf].
func NewOneOfBool(o bool) OneOf {
	return OneOfBool(o)
}

// NewOneOfAttrs constructs a value of type `attrs` that satisfies [OneOf].
func NewOneOfAttrs(o map[string]any) OneOf {
	return OneOfAttrs(o)
}

// OneOfJSON wraps [OneOf] and implements the json.Unmarshaler interface.
type OneOfJSON struct{ Value OneOf }

// UnmarshalJSON implements the [json.Unmarshaler] interface for [OneOf].
func (o *OneOfJSON) UnmarshalJSON(data []byte) error {
	v, err := unmarshalOneOf(data)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements the [json.Marshaler] interface for [OneOf].
func (o OneOfJSON) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.Value)
}

func unmarshalOneOf(data json.RawMessage) (OneOf, error) {

	var v0 int
	if err := json.Unmarshal(data, &v0); err == nil {
		return OneOfInt(v0), nil
	}

	var v1 string
	if err := json.Unmarshal(data, &v1); err == nil {
		return OneOfStr(v1), nil
	}

	var v2 bool
	if err := json.Unmarshal(data, &v2); err == nil {
		return OneOfBool(v2), nil
	}

	var v3 map[string]any
	if err := json.Unmarshal(data, &v3); err == nil {
		return OneOfAttrs(v3), nil
	}

	return nil, errors.New("failed to unmarshal OneOf: unknown type received")
}
